









php의 변수는 타입을 따로 결정하지 않는다. 대신 변수에 대입되는 값에 따라 타입이 알아서 결정된다.
is_int(), is_string() 등의 함수로 변수의 타입을 체크한다.
gettype()은 단순히 눈으로 볼 때 사용하자.
NAN과는 무엇을 비교하든 false다.(자기 자신도)
php에서 문자열은 유니코드 방식이 아니다. 영어는 1byte, 한글은 3byte

''(작은 따옴표)로 문자열을 표기할 경우 '(작은 따옴표)를 리터럴로 표기하려면 \를 붙이면 된다.
단, 다른 문자 앞에 \를 붙여도 아무런 효과가 없다. 그냥 그대로 출력된다.
\는 (')앞만 아니면 정상적으로 출력된다. (')앞이면 (')를 이스케이프 해주는 역할을 하기 때문이다.
(')앞에서 \를 출력하기 위해선 \\ 이렇게 두번 써주면 된다.
echo '\\'; -> \
echo '\''; -> '
echo '\'; -> 에러
echo '\ '; -> \ (뒤에 공백 포함, 공백 앞에 써도 정상적으로 출력된다.)
\r, \n등의 이스케이프 시퀀스를 쓰려면 ""(큰 따옴표)를 써야 한다.

""(큰 따옴표)안에서는 변수를 문자열로 삽입해도 인식된다.
$a = 1; echo "a= $a"; // a = 1 출력
""(큰 따옴표)안에서 변수명을 명시적으로 표시하고 싶다면 {}를 사용한다.
$abc = 'apple';
echo "$abcs"; //에러
echo "{$abc}s"; //apples
또한 {}을 인식하는 것은 '{'바로 뒤에 $가 나오는 경우에서다.)
echo "{ $abc}" //{ apple} 이런식으로 출력된다.

문자열을 배열처럼 접근할 수도 있다.
$str = 'This is a test.' ; 
$first = $str [ 0 ]; 
echo $first; // T
마지막 문자열을 뽑아내는 예
$str = 'This is' ; 
$last = $str [ strlen ( $str )- 1 ]; 
echo $last;

배열 표기법은 두가지가 있다.
$array = array("foo" => "bar", "bar" => "foo",);
// PHP 5.4 부터 가능
$array = ["foo" => "bar", "bar" => "foo",];
참고로 마지막에 ','를 붙여도 되고 안 붙여도 된다.

$array = array(-100  => 100,); 키 값에 음수를 넣을 수 있다.

unset()으로 배열 요소를 지운 뒤 빈 키 값([])으로 값을 대입할 경우 지워진 요소 다음 키부터 들어간다.
$arr = array(1);
unset($arr[0]);
$arr[] = 2; // 이 값의 키는 0이 아니라 1이된다.
$arr = array_values($arr); // array_values() 함수로 순서를 다시 0부터 정리한다.

NULL은 빈 값은 NULL형의 유일한 값이다.

php 변수의 범위는 '전역, 로컬, 정적' 변수로 3가지이다.
php에서 로컬(지역) 변수란 오직 함수 내의 변수를 말한다.
함수 외부에 있는 변수는 모두 전역 변수이다.

$a = 1;
$b = 2;
function Sum()
{
    global $a, $b;
    $b = $a + $b;
}
Sum();
echo $b; // 3이 출력된다. 만약 함수 내에 global 선언이 없다면 전역 변수를 참조할 수 없다.
전역 변수 $a, $b는 global로 선언한 것과 마찬가지이다.(굳이 안 써줘도 된다.)
즉, global 키워드는 로컬 영역에서 전역 변수를 호출하기 위해 있는 키워드라고 볼 수 있다.

정적 변수는 지역, 전역 변수 모두 될 수 있다.
지역변수로서 선언이 됐다면 함수가 처음 호출할 때 값이 초기화 되고 그 뒤에 호출할 땐 값이 계속 유지된다.
function test()
{
    static $a = 0;
    echo $a;
    $a++;
}
 test(); //0
 test(); //1
 test(); //2

가변 변수
$a = 'hello';
$$a = 'world';
echo $hello; //world
echo $$a //world
$a에 해당하는 문자열의 변수 즉, $hello가 생기는 것이다.

상수화 하기
define('ten', 10);
echo ten * 4; //40
상수화하면 $기호 등 없이 이름만으로 사용 가능하다.

나머지 연산에서 주의할 점
echo (5 % 3)."\n";           // 2
echo (5 % -3)."\n";          // 2
echo (-5 % 3)."\n";          // -2
echo (-5 % -3)."\n";         // -2

참조 변수
$a = 4;
$b = &$a; //&키워드를 이용하여 $a에 대한 참조 변수 $b를 만든다.
$b = 5;
echo $a // 5가 출려된다.
즉, $a에 $b라는 별명을 하나 더 붙여준다고 생각하면된다.
실제로 같은 메모리 공간을 사용하는 완전히 같은 변수다.

비교 연산
===, !== 는 타입까지 비교한다.
=== 타입을 포함한 값까지 모두 같아야 참
!== 값과 타입 중 하나만 달라도 참

``(역따옴표 연산자)
$output = `ls -al`;
echo "<pre>$output</pre>";
'명령어' 내부의 명령어가 실행되고 그 결과가 반환된다. shell_exec() 함수를 쓴 것과 같은 효과이다.
system()으로 명령어를 실행할 경우 바로 결과가 출력된다.

배열 연산자
배열 합집합 연산자 '+'
$a = array("a" => "apple", "b" => "banana");
$b = array("a" => "pear", "b" => "strawberry", "c" => "cherry");
$c = $a + $b; // Union of $a and $b
echo "Union of \$a and \$b: \n";
var_dump($c);
출력:
Union of $a and $b:
array(3) {
  ["a"]=>
  string(5) "apple"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "cherry"
}
다음과 같이 출력된다. 즉, 왼쪽 기준으로 겹치지 않는 '키'를 가진 원소만 합쳐진다.

$a = array(0 => "apple", 3 => "banana");
$b = array(0 => "pear", 1 => "strawberry", 2 => "cherry");
print_r($c);
출력:
Array
(
    [0] => apple
    [3] => banana
    [1] => strawberry
    [2] => cherry
)
위처럼 키가 겹치면 아예 합쳐지지 않고 키값이 더 작더라도 순서는 왼쪽 배열의 원소들이 더 먼저 온다.

비교
$a = array("apple", "banana");
$b = array(1 => "banana", "0" => "apple");
var_dump($a == $b); // bool(true) 원소들의 키와 값만 같으면 참이다.
var_dump($a === $b); // bool(false) 원소들의 키와 값 그리고 타입, 순서까지 같아야 참이다.

list() 함수
$info = array('coffee', 'brown', 'caffeine');
// 모든 변수를 목록화한다
list($drink, $color, $power) = $info;
echo "$drink is $color and $power makes it special.\n";
// 그들중 일부를 목록화한다
list($drink, , $power) = $info;
echo "$drink has $power.\n";
// 또는 세번째 값으로만 건너띈다
list( , , $power) = $info;
echo "I need $power!\n";
**주의!! list()함수는 연관배열에서는 작동되지 않는다.

each() 함수
$foo = array("Robert" => "Bob", "Seppo" => "Sepi");
$bar = each($foo);
print_r($bar);
Array
(
    [1] => Bob
    [value] => Bob
    [0] => Robert
    [key] => Robert
)
이런식으로 key와 value를 얻을 수 있다.
한번 더 실행하면 다음 원소의 key와 value를 반환한다.
즉, 실행과 동시에 배열의 커서가 한칸 이동하는 것이다.
커서를 처음 위치로 보내기 위해 reset($foo)를 해주면 된다.

reset($fruit);
while (list($key, $val) = each($fruit)) {
    echo "$key => $val\n";
}
이런식으로 foreach문 같은 효과를 낼 수 있다.

while ($fruit_name = current($array)) {
    if ($fruit_name == 'apple') {
        echo key($array).'<br />';
    }
    next($array);
}
이런식으로 key()함수와 next()함수로를 통해 키값을 구할 수 있다.
key()는 커서를 이동시키지 않기 때문에 next()를 써준 것이다.
그외 이런 함수들이 있다.
list() - 배열처럼 변수에 할당
key() - 배열의 현재 키를 반환
current() - 배열의 현재 원소의 값을 반환
reset() - 배열의 내부 포인터를 첫 원소로 설정
next() - 배열의 내부 배열 포인터를 전진
prev() - 내부 배열 포인터를 후진



instanceof 연산자
변수 instanceof 클래스명 // 해당 변수가 해당 클래스의 인스턴스일 수 있나
$a instanceof MyClass
변수 자체의 클래스이거나 부모 클래스일 경우 참이다.
인터페이스를 구현한 경우도 해당된다.

foreach 문법
$arr = array(1, 2, 3, 4);
foreach ($arr as &$value) {
    $value = $value * 2;
}
unset($value)
이런식으로 참조를 이용하여 실제 변수의 값을 바꿀 수 있지만 마지막 요소의 참조 변수를 언셋해야 문제 발생을 막을 수 있다.

continue의 기본값은 1이다.
$i = 0;
while ($i++ < 5) {
    echo "Outer<br />\n";
    while (1) {
        echo "Middle<br />\n";
        while (1) {
            echo "Inner<br />\n";
            continue 3; // 세번째 루프 밖으로 나간다.
        }
        echo "This never gets output.<br />\n";
    }
    echo "Neither does this.<br />\n";
}
이런식으로 외부 루프로 빠져나갈 수 있다.

함수 안의 함수
function foo() 
{
  function bar()
  {
    echo "I don't exist until foo() is called.\n";
  }
}
bar()는 foo()가 호출된 시점에 정의된다. 즉, 한번이라도 foo()가 호출된 다음 bar()를 호출할 수 있다.
함수가 호출부보다 아래에 있어도 호출 가능하다.(C랑은 다름)

함수 내부에서 인수에 대한 정보를 알려주는 함수들
func_num_args () , func_get_arg () , func_get_args () 
위 세 함수를 통해 인자수가 다양한 함수를 만들 수 있다.
function a()
{
	$arr = func_get_args(); // 이 함수가 제일 유용할 듯
	$c = 0;
	foreach($arr as $v)
	{
		$c += $v;
	}
	echo $c;
}
a(1,2,3,4,5,6); //21

함수 인자 타입을 한정할 수 있다.
스칼라형의 타입 한정은 php7부터 가능하다.
보통은 클래스 타입, 인터페이스 타입을 한정하는 용도로 사용된다.
class C {}
class D extends C {}
class E {}
function f(C $c) {
    echo get_class($c)."\n";
}
f(new C); //C
f(new D); //D 상속 받은 클래스 역시 가능하다.
f(new E); // 에러

가변 함수
가변 변수와 사용법이 흡사하다.
function foo()
{
    echo "hi";
}
$func = 'foo';
$func(); //hi
문자열 변수 뒤에 ()를 붙여주면 해당 문자열 이름의 함수를 호출한다.

익명함수 or 클로저
두가지 명칭으로 같이 쓰인다.
function()
{
	echo 'hi';
}
기본적으로 다음과 같은 문법으로 이름 없이 만들어진 함수를 말한다.
단, 위 함수는 이름이 없기에 호출도 할수 없다.
따라서 callback함수로서 파라미터에 바로 대입되거나 변수 대입되어 가변 함수로 사용된다.
$arr = array(2,4,1,3);
usort($arr,function($a, $b)
{
	if($a>$b)
		return 1; // 왼쪽이 클 때 1을 리턴해야 오름차순이다.
	elseif($a<$b)
		return -1;
	else
		return 0;
});
이런식으로 usort의 callback함수를 익명함수로 대입했다.
$a = function(){
	echo 'hi';
}; // 대입문이기에 세미콜론을 해줘야 한다는 것을 잊지 말자.
$a();
이런식으로 가변 함수를 통해 호출할 수도 있다.

클래스 기초
class SS
{
    // 프로퍼티 정의
    public $var = 'a default value';

    // 메서드 정의
    public function foo() {
        $this->boo(); // 멤버 메서드의 접근을 위해 $this를 활용한다.
    }
    public function boo() {
        echo $this->var; // 멤버 변수 역시 접근하려면 $this를 활용한다.
    }
}
$inst = new SS();
$inst-> foo();
php의 클래스의 메서드는 멤버변수나 멤버메서드에 접근하기 위해 무조건 '$this'를 사용해야 한다.
다른 언어에서는 this키워드 없이 되는 경우가 대부분이지만 php는 다르다!

$this는 객체가 생성되고 난 뒤에만 존재한다.
class A
{
    function foo()
    {
        if (isset($this)) {
            echo '$this is defined (';
            echo get_class($this);
            echo ")\n";
        } else {
            echo "\$this is not defined.\n";
        }
    }
}
A::foo(); //$this is not defined. 
$inst = new A();
$inst->foo(); //$this is defined (A)
//php는 정적 메서드가 아니라도 그냥 호출이된다. 단, 경고가 발생한다.

가변변수를 사용하여 인스턴스를 생성할 수 있다.
$className = 'SimpleClass';
$instance = new $className(); // new SimpleClass()

인스턴스를 다른 변수에 대입할 경우
결론부터 말하면 JAVA처럼 인스턴스가 복제되지 않는다.
복제를 위해선 __clone()메서드를 사용한다.

$instance = new SimpleClass();
$assigned   =  $instance; //$instance객체에 대한 참조변수가 하나 더 생긴 것
$reference  = &$instance; //$instance라는 변수에 별명이 하나 더 생긴 것
//즉, $instance, $assigned, $reference 모두 같은 객체를 참조하는 변수다.
단, $instance = null; 이경우 $instance의 별명인 $reference 변수또한 null된다.
그러나 $assigned는 여전히 해당 객체를 참조하고 있다.

상속(확장)
class ExtendClass extends SimpleClass
{
    // Redefine the parent method
    function displayVar()
    {
        echo "Extending class\n";
        echo $this->var;
        parent::displayVar();
    }
}
이런식으로 상속받을 수 있다.
부모의 메서드를 호출하기 위해선 parent::키워드를 사용한다.($this로 접근하면 자기 메서드부터 찾는다.)
부모의 멤버 변수는 $this로 접근하면 된다.
단, $this는 현재 클래스부터 탐색한다.
따라서 현재 클래스에 존재하는 멤버변수면 그것에 접근한다.(가림 현상 발생)

class SimpleClass
{
    // 프로퍼티 정의
    public $var = 'a default value';

    // 메서드 정의
    public function foo() {
        echo $this->var;
    }
}
class ExtendClass extends SimpleClass
{
	public $var = '상속';
    // Redefine the parent method
    function displayVar()
    {
        echo $this->var;
        parent::foo(); //이 메소드가 찾아가는 $this는 부모 것이 아니다.
    }
}
$extended = new ExtendClass();
$extended->displayVar(); // 상속상속
이런식으로 호출된다는 것은 php '동적 영역 규칙'을 따른다고 봐야겠다.
자바에선 상속a default value가 출력될 것이다.

오버라이딩
부모클래스의 함수명과 인자의 수, 순서, 반환형까지 같은 함수를 말한다.
**근데 php에선 사실상 메소드명만 같으면 오버라이딩이 되는 듯하다.

가시성
php 역시 public, protected, private 키워드를 사용한다.
의미 역시 다른 언어와 같다.
단, 멤버 변수를 선언할 때 반드시 셋 중 하나를 명시해줘야 한다.
디폴트 값이 없기에 명시하지 않으면 에러가 난다.
**자식 클래스에서 오버로딩 되는 메서드의 접근제어자는 부모보다 좁을 수 없다.

메소드는 접근 키워드를 표시 안해도 된다. 그 경우 디폴트로 public이 된다.
class MyClass
{
    // Declare a public constructor
    public function __construct() { echo 'hi'; }

    // Declare a public method
    public function MyPublic() {  echo 'hi'; }

    // Declare a protected method
    protected function MyProtected() {  echo 'hi'; }

    // Declare a private method
    private function MyPrivate() {  echo 'hi'; }

    // This is public
    function Foo()
    {
        $this->MyPublic();
        $this->MyProtected();
        $this->MyPrivate();
    }
}
위 처럼 멤버 변수에서 다른 멤버 변수에 접근할 때도
$this키워드를 무조건 사용해야 한다. 이것은 멤버 변수에 접근할 때도 마찬가지다.
역시 이 부분은 java등의 언어와 다르다.

private메서드는 상속되지 않는다. 따라서 오버라이딩 되지도 않는다.
class Bar 
{
    public function test() {
        $this->testPrivate();
        $this->testPublic();
    }

    public function testPublic() {
        echo "Bar::testPublic\n";
    }
    
    private function testPrivate() {
        echo "Bar::testPrivate\n";
    }
}
class Foo extends Bar 
{
    public function testPublic() {
        echo "Foo::testPublic\n";
    }
    
    private function testPrivate() {
        echo "Foo::testPrivate\n";
    }
}
$myFoo = new foo();
$myFoo->test();
// Bar::testPrivate 
// Foo::testPublic
다음과 같이 호출된다. testPublic()는 오버로딩 됐지만 testPrivate()는 그렇지 않다.

같은 클래스 타입의 객체의 메소드 내에서는 protected, private 멤버에 접근 가능하다.
class Test
{
    private $foo;

    public function __construct($foo)
    {
        $this->foo = $foo;
    }

    private function bar()
    {
        echo 'Accessed the private method.';
    }

    public function baz(Test $other) // 같은 타입의 객체를 인자로 받는다.
    {
        // We can change the private property:
        $other->foo = 'hello'; // 객체 내부에서는 다른 같은 타입 객체의
        $other->bar();         // protected, private 멤버에 접근 가능하다.
    }
}
$test = new Test('test');
$test->baz(new Test('other'));

class 내에서의 static 키워드
함수 내에서의 static 키워드와 의미가 다르다는 것을 알 것이다.
static멤버는 알다시피 인스턴스 생성없이 호출가능한 멤버를 말한다.
class AA{
  public static $foo = 'foo';
  public static function bar()
  {
    echo 'bar';
  }
}
echo AA::$foo; // foo
정적 멤버변수는 이런식으로 접근할 수 있다.
AA::bar(); // bar
정적 메서드 또한 같은 방법으로 호출할 수 있다.
::은 더블콜론이라 부른다.

자신 클래스의 정적 멤버에 대한 접근은 self::를 사용한다.
부모 클래스의 정적 멤버에 대한 접근은 parent::를 사용한다.(단, 클래스 이름으로도 가능하다.)
class Foo
{
    public static $my_static = 'foo';

    public function staticValue() {
        return self::$my_static;
    }
}
class Bar extends Foo
{
    public function fooStatic() {
        return parent::$my_static; //Foo::$my_static 이런식으로 클래스명으로도 접근 가능하다.
    }
}

정적 멤버 변수는 인스턴스로 접근할 수 없다.
하지만 정적 메소드는 인스턴스로 접근할 수 있다!
$foo = new Foo();
print $foo->staticValue() . "\n"; // 가능(정적 메소드는 가능)
print $foo->my_static . "\n";      // 불가능(정적 속성은 불가능)
print Bar::$my_static . "\n"; //부모의 정적 멤버도 자식 클래스명으로 호출할 수 있다.
$bar = new Bar();
print $bar->fooStatic() . "\n"; //인스턴스로 부모의 정적 메소드 접근도 가능하다.
**정적 멤버도 접근지정자에 대한 효과는 똑같이 적용된다.

클래스 상수 
const 키워드를 이용해 클래스 내에 상수를 정의할 수 있다.
접근 방법은 정적 속성과 같다.
단, 상수인 만큼 $없이 사용된다.(선언할 때도 마찬가지다.)
class MyClass
{
    const CONSTANT = 'constant value'; // $가 사용되지 않는다.

    function showConstant() {
        echo  self::CONSTANT . "\n";// 역시 $가 사용되지 않는다.
    }
}
echo MyClass::CONSTANT . "\n";
$class = new MyClass();
$class->showConstant();

:: 스코프 연산자
부모 멤버에 접근, 정적 멤버 접근, 클래스 상수 접근에 사용된다.
parent:: -> 부모 메소드에 접근(부모 프로퍼티 접근은 X), 부모 정적 메소드에 접근, 부모 정적 프로퍼티에 접근
self:: -> 자신의 정적 멤버에 대한 접근
클래스명:: -> 외부에서 정적 멤버에 대한 접근

생성자
php에선 자식 클래스에서 생성자를 정의한 경우 그 자식 생성자가 디폴트로 부모 생성자를 호출하지 않는다.
다른 언어와 다른 점이다!
따라서 자식 생성자에 parent::__construct()로 부모 생성자를 호출해줘야 한다.
class BaseClass {
   function __construct() {
       print "In BaseClass constructor\n";
   }
}
class SubClass extends BaseClass {
}
$obj = new SubClass();
// 이처럼 자식 클래스가 생성자를 따로 정의하지 않으면 부모 생성자가 호출된다.

class BaseClass 
{
   function __construct() 
   {
       print "In BaseClass constructor\n";
   }
}
class SubClass extends BaseClass 
{
   function __construct() 
   {
       print "In SubClass  constructor\n";
   }
}
$obj = new SubClass();
// 자식 클래스에서 따로 정의한 경우 자식 생성자만 호출된다.

C++, JAVA등의 다른 언어들처럼 부모 생성자부터 호출하기위에 다음과 같이 한다.
class BaseClass {
   function __construct() {
       print "In BaseClass constructor\n";
   }
}
class SubClass extends BaseClass {
   function __construct() {
       parent::__construct(); // 이렇게 부모 생성자부터 호출해준다.
       print "In SubClass constructor\n";
   }
}

특이한 점으로 자식 클래스를 포함한 모든 자손 클래스는 자기 클래스에서 정의한 생성자가 없을 경우
'최상위 클래스의 생성자'를 상속받는다. 바로 위 부모 클래스의 생성자를 상속받는 것이 아니다! 
class BaseClass {
   function __construct() {
       print "In BaseClass constructor\n";
   }
}

class SubClass extends BaseClass {
   function __construct() {
       parent::__construct();
       print "In SubClass constructor\n";
   }
}

class OtherSubClass extends BaseClass {
    // 이 클래스는  BaseClass의 생성자를 상속받는다.
}

소멸자
소멸자는 unset등으로 객체를 참조하는 변수가 하나도 남지 않은 경우와 스크립트가 종료된 경우 호출된다.
예) $inst=null, unset($inst), exit나 die로 종료한 경우
생성자와 같이 부모 클래스의 소멸자가 엔진에 의해 암묵적으로 호출되는 것은 아니다.
부모 클래스의 소멸자를 실행하려면 소멸자에서 명시 적으로 parent:: __ destruct () 를 호출해야 한다.
또한 생성자와 마찬가지로 자식 클래스에서 소멸자를 정의하지 않은 경우는 부모 클래스의 소멸자를 상속받는다.
역시 자손 클래스에서 정의하지 않을 경우 최상위 클래스의 것을 상속 받는다.

추상 클래스, 메소드
추상 클래스는 인스턴화 될 수 없는 클래스를 말한다.
클래스 선언 부에 'abstract' 키워드를 명시하면 추상 클래스가 된다.
추상 메소드는 구현부가 없이 프로토타입만 있는 메소드를 말한다.
구현부가 없는 추상메소드를 선언하기 위해서 역시 'abstract'키워드를 명시해주면 된다.
abstract class AbstractClass //추상 클래스
{
    abstract protected function getValue(); //추상 메소드
    abstract protected function prefixValue($prefix);

    public function printOut() { //일반 메소드도 가질 수는 있다.
        print $this->getValue() . "\n";
    }
}
추상 메소드를 하나라도 가진 클래스는 추상 클래스가 된다.
즉, 클래스 선언부에 'abstract' 명시 해야만 한다. 그렇지 않으면 에러다.
추상 메소드를 상속받는 경우 상속받은 추상메소드의 구현부를 정의하거나
상속받는 클래스도 'abstract'을 명시하면 된다. 그렇지 않으면 에러다.
abstract class AA
{
	public $a = 3; // 추상클래스도 멤버 변수는 가질 수 있다.
	abstract function foo($a);
}
class BB extends AA
{
	function foo($a)
	{                   
		
	}
}
abstract class AA
{
	abstract function foo(CC $a);
}
class BB extends AA
{
	function foo(DD $a) // 타입이 다른 경우도 에러다.(이것은 인터페이스도 마찬가지다.)
	{                   
		
	}
}
인터페이스
interface도 추상메서드와 흡사하다.
역시 인스턴스화 할 수 없다.
단, 멤버 변수를 가질 수 없고 모든 메소드의 구현부가 무조건 없어야 한다.(단, abstact를 명시하지 않는다.)
또한 모든 메소드는 public이어야 한다.
인터페이스를 상속받은 클래스는 반드시 인터페이스의 추상메소드와 똑같은 프로토타입의 메소드를 정의해야 한다.
추상메소드의 경우 추가적인 인자를 받을 수 있었지만 인터페이스는 불가능하다.
interface AA
{
	function foo($a);
}
class BB implements AA // extends가 아닌 implements 키워드를 사용한다.
{
	function foo($a, $b) // 정의부가 다르기에 에러다.
	{
		
	}
}

인터페이스 끼리는 상속 관게가 가능하다. 즉, extends 가능
(이 때는 상위 인터페이스의 메서드 정의부를 작성 안해도 됨)
interface a
{
    public function foo();
}
interface b extends a
{
    public function baz(Baz $baz);
}
class c implements b
{
    public function foo()
    {
    }

    public function baz(Baz $baz)
    {
    }
}
대신 b를 구현받은 c는 a, b의 모든 추상메소드의 구현부를 정의해줘야 한다.

인터페이스도 상수를 가질 수 있다.
interface a
{
    const b = 'Interface constant'; // 접근제어자는 써주지 않는다.
}
echo a::b;

객체 순회
foreach로 객체 내 속성들을 순회할 수 있다.
단, 가시적인 속성들만 순회한다.
class MyClass
{
    public $var1 = 'value 1';
    public $var2 = 'value 2';
    public $var3 = 'value 3';

    protected $protected = 'protected var';
    private   $private   = 'private var';

    function iterateVisible() {
       echo "MyClass::iterateVisible:\n";
       foreach($this as $key => $value) { // 모든 속성 순회 가능
           print "$key => $value\n";
       }
    }
}
$class = new MyClass();
foreach($class as $key => $value) { // public 속성만 순회 가능
    print "$key => $value\n";
}
$class->iterateVisible();
** 그외 Iterator 인터페스를 이용한 방법도 있는데 일단은 패스...

매직 메소드
클래스 내의 특정 동작에 해당하는 메소드를 만들기위한 특별한 메소드들이다.
대표적인 예로 __toString()이 있다.(java의 그것과 비슷하다.)
class TestClass
{
    public function __toString()
    {
        return '이것은 테스트 클래스다.'; //객체가 echo 됐을 때 출력될 문자열을 정의할 수 있다.
    }
}
$class = new TestClass();
echo $class; //이것은 테스트 클래스다.

__clone()
이것도 매직 메소드 중 하나인데 인스턴스를 복제할 때 사용된다.
위에서 보다시피 php에서 객체끼리의 대입연산은 복제가 아닌 동일한 객체 참조가 된다.
단순히 복제하고 싶을 때는 다음과 같은 방식을 사용한다.
class AA
{
	public $a = 1;
	public $b = 1;
	public function __clone()
	{
		$this->a++; // 복제 대입 일어나기 직전에 처리되는 동작들이다.
	}
}
$inst1 = new AA();
$inst2 = clone $inst1; // clone 연산자를 이용해 복제 대입한다.
print_r($inst1);
print_r($inst2);
// 결과: AA Object ( [a] => 1 [b] => 1 ) AA Object ( [a] => 2 [b] => 1 )
// __clone()의 정의 없이 단순히 복제 대입할 경우 속성의 값들만 복제 된다.
//여기서는 특별히 $a만 따로 처리를 해줘서 값이 1증가했고 $b는 똑같은 값으로 복제 됐다.
// 복제 인스턴스기에 $inst1의 속성들의 값이 변해도 $inst2에는 영향을 주지 않는다.
// clone 키워드 없이 $inst2 = $inst1; 이렇게 했다면 동일 객체 참조가 되어 값도 같이 변했을 것이다.

final 키워드
final 클래스는 상속 받을 수 없다.
final 메소드는 오버라이딩 할 수 없다.

객체 비교 연산
객체 == 객체 (같은 클래스의 객체면서 속성들의 값이 같으면 참이다. 각각 독립적인 객체여도 가능)
객체 === 객체 (같은 객체를 '참조'할 경우에만 참이다.)
서로 다른 클래스의 객체를 비교할 경우는 항상 거짓이다.

객체를 함수의 인자로 넣었을 때
class A {
    public $foo = 1;
}

function foo($obj) {
    $obj->foo = 2;
}
$e = new A;
foo($e);
echo $e->foo; // 2
// 인자로 넘어갈 때 $obj = $e 가 실행되는 것이나 마찬가지다.
// 위에서 봤다 싶이 이 방식으로 하면 동일 객체의 참조가 된다. 따라서 실제 객체의 값 역시 변하게 된다.

시리얼라이즈
시리얼라이즈를 통해 객체, 배열 등을 문자열로 만들 수 있다.
주로 데이터 전송할 때 사용될 듯 싶다.
class AA
{
	public $a = 3;
}
$inst = new AA();
$AA = serialize($inst); // 시리얼라이즈했던 것을
$AA = unserialize($AA); // 다시 풀면 객체로 돌아온다.
echo $AA->a;
단, unserialize하는 지점에 정의된 해당 class가 이미 있어야 한다.(인클루드하든지 어쩌든지 해서)

네임스페이스
네임스페이스는 '클래스, 함수, 상수' 등의 이름 중복을 막아준다.
보통은 하나의 php파일에 하나의 이름공간을 부여하는 식이다.
따라서 각각 다른 이름공간을 부여했다면 여러가지 이점이 생긴다.
그 공간 내에서 다른 공간에 존재하는 '클래스, 함수, 상수' 명등을 사용해도 include했을 때 구분할 수 있다.
//AA.php
<?php
namespace language\en;
function welcome(){
    return 'Hello world';
}
//BB.php
<?php
namespace language\ko;
function welcome(){
    return '안녕하세요';
}
//test.php
<?php
require_once 'greeting_ko_ns.php';
require_once 'greeting_en_ns.php';
echo language\ko\welcome(); 
echo language\en\welcome();
//이처럼 같은 이름의 함수를 인클루드했지만 네임스페이스로 각각 구분하여 호출할 수 있다.
?>

한 파일에 여러 네임스페이스를 쓰는 방법
namespace MyProject { // 첫 번째 이름 공간
const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }
}
namespace AnotherProject { // 두 번째 이름 공간
const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }
}
namespace { // 네임스페이스에 속하지 않는 공간도 정의할 수 있다.
session_start();
$a = MyProject\connect();
echo MyProject\Connection::start();
}

네임스페이스 공간에서 자기 자신 네임스페이스의 '클래스, 함수, 상수' 등에 접근할 때는 경로를 명시하지 않아도 된다.
단 이름 공간 내에서 *전역 '클래스, 함수, 상수' 등을 호출할 땐 '\'을 붙여 줘야 한다.
<?php
namespace Foo;
class AA{};
$a = new AA(); // 이것은 $a = new Foo\AA(); 와 같다.
?>

<?
namespace Foo;
function strlen($a)
{
	return false;
}
$c = strlen('asdf'); //Foo\strlen()을 호출한다.
$c = \strlen('asdf'); // 전역 함수 strlen()을 호출한다.
?>

예외 처리
다음 예제들만 해석할 수 있으면 된다.
//예제 1
function inverse($x) {
    if (!$x) {
        throw new Exception('Division by zero.');
    }
    return 1/$x;
}

try {
    echo inverse(5) . "\n";
} catch (Exception $e) {
    echo 'Caught exception: ',  $e->getMessage(), "\n";
} finally {
    echo "First finally.\n";
}

try {
    echo inverse(0) . "\n";
} catch (Exception $e) {
    echo 'Caught exception: ',  $e->getMessage(), "\n";
} finally {
    echo "Second finally.\n";
}

예제 2
class MyException extends Exception { }

class Test 
{
	public function testing() 
	{
		try
		{
			try
			{
				throw new MyException('foo!');
			}
			catch (MyException $e)
			{
				// rethrow it
				throw $e;
			}
		} 
		catch (Exception $e)
		{
			var_dump($e->getMessage());
		}
	}
}

$foo = new Test;
$foo->testing();

참조 정리
function AA(&$a) // 인자를 받는 함수에서 참조로 받는 값으로 받는지 결정한다.
{
	$a = 3;
	return $a;
}
$b = 4;
AA($b);
echo $b; //3이 출력된다.
**참고 AA(&$b) 이런식으로 함수 인자로 참조를 보내는 문법은 불가능하다!!!

unset을 한 경우
$a = 1;
$b = &$a;
unset($a); // $a를 지웠지만 여전히 $b는 유효하다.(별명 중 하나를 지운 것이나 마찬가지다.)
echo $b; // 단, $a = null을 하면 $b도 null이 된다.

참조를 반환
1. 함수에서 참조 반환
함수에서 참조값을 반환하기 위해선 함수 정의부에서 함수 이름 앞에 &를 붙여줘야 한다.
또한 반환 값을 참조로 받기 위해서도 &를 붙여 줘야 한다.
둘 중 하나라도 안하면 그냥 값 전달이 된다.
function &AA() // &를 붙여 줬다.
{
	static $num = 1;
	return $num;
}
$foo = &AA(); // 참조로 받기 위해 &를 붙여 준다.
echo $foo; // 1
$foo = 2;
$bar = &AA();
echo $bar; // 2
2. 메서드에서 참조 반환
class foo {
    public $value = 42;
    public function &getValue() { //역시 참조 반환을 위해 &를 붙여 줬다.
        return $this->value;
    }
}
$obj = new foo;
$myValue = &$obj->getValue(); //역시 &를 붙여준다.
$myValue = 5; 
echo $obj->value; // 5가 출력된다.
//이런식으로 객체의 속성을 참조하는 변수 $myValue를 만들었다.

http header란?
정보기술에서 헤더(header)는 저장되거나 전송되는 데이터 블록의 맨앞에 위치한 보충 데이터를 가리킨다.
데이터 전송에서 헤더를 따르는 데이터는 페이로드(payload), 바디(body)로 불리기도 한다.
헤더 구성은 구문 분석을 위하여 뚜렷하고 모호하지 않은 규격이나 포맷을 따라야 한다.

서버에 요청하는 클라이언트 입장에서 헤더를 포함시켜 요청할 수 있고
요청에 응답하는 서버 입장에서도 헤더를 포함시켜 응답할 수 있다.
header()함수로 작성된 헤더는 클라이언트 입장에서 받아보는 헤더이다.
header()함수는 한줄의 헤더를 정의할 수 있다.
header(헤더 문자열, 대체 여부=true, response_code를 특정 코드로 강제함)
대체 여부: 같은 타입의 헤더를 여러개 정의했을 때 true일 경우 마지막 것으로 덮어써지게 되고 false일 경우 모두 포함된다.
header("Expires: Mon, 26 Jul 1997 05:00:00 GMT");
header("Cache-Control: no-cache");
header("Pragma: no-cache");
// 이런식으로 한 줄에 하나의 타입의 헤더를 정의한다.
위와 같은 헤더를 추가함으로 클라이언트가 자의적으로 바꾼 브라우저 설정을 덮어쓰기 할 수 있다.
<?php
header("Content-type:application/pdf");
// It will be called downloaded.pdf
header("Content-Disposition:attachment;filename='downloaded.pdf'");
// The PDF source is in original.pdf
readfile("original.pdf");
이런식의 코드로 사용자가 바로 pdf파일을 다운 받을 수 있도록 할 수 있다.

서버로 온 요청 헤더는 다음 함수로 확인할 수 있다.
apache_request_headers( void ) 또는 getallheaders( void )
두 함수 다 같은 건데 앞에 걸로 이름이 바뀌었다.
모든 헤더의 키, 값을 array를 리턴한다.
**이것으로 네아로 api의 의문점이 거의 풀렸다.

cURL 정리
cURL은 클라이언트 url의 표준이다.
cURL은 http, ftp 등의 프로토콜을 경우하는 데이터 전송을 위한 라이브러리다.
cURL을 사용함으로 get, post 같은 다양한 메소드로 HTTP 요청을 보낼 수 있다.
따라서 이종 프로토콜간의 통신을 지원한다.
기본적인 작동 코드:
$curl = curl_init(); // cURL 세션을 초기화 및 cURL핸들 리턴
curl_setopt($curl, CURLOPT_URL, "http://www.google.co.in"); // url설정
curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); // 실행 결과를 문자열로 반환하도록 설정
$result = curl_exec($curl); // 전송 실행 및 결과값 리턴
curl_close($curl); // cURL 종료(안전하게 전송을 종료하자.)
print $result; // 결과 출력

$curl = curl_init('http://www.google.co.in'); //이렇게 하는 것과

$curl = curl_init();
curl_setopt($curl, CURLOPT_URL, "http://www.google.co.in"); //이렇게 하는 것은 같다.

curl_setopt()을 여러번 쓰는 대신 curl_setopt_array()를 써도 된다.
$options = array(CURLOPT_URL => 'http://www.example.com/',
                 CURLOPT_HEADER => false
                );
curl_setopt_array($ch, $options);

원래 curl_exec() 함수는 성공 여부에 따라 true나 false를 반환한다.
단, CURL_RETURNTRANSFER 온션을 true로 하면 페이지 output을 문자열로 반환한다.

curl_exec($curl)로 실행한 뒤에 curl_getinfo()로 전송에 대한 정보를 배열로 반환받을 수 있다.
$result = curl_exec($curl);
$info = curl_getinfo($curl); // 전송 정보 배열로 반환
echo curl_error($curl); // 에러가 있다면 에러 정보를 반환하고 없으면 빈 문자열을 반환한다.

cURL로 헤더를 보내는 방법과 받는 방법
curl_setopt($curl_session, CURLOPT_HTTPHEADER, array('aa: bb'))
// 이 옵션으로 리퀘스트의 헤더를 추가해 보낼 수 있다.
curl_setopt($request, CURLOPT_HEADER, 1);
// 이 옵션으로 리스폰스의 헤더를 확인할 수 있다.
리스폰스 헤더가 포함된 문자열은 다음과 같다.
HTTP/1.1 200 OK
Server: nginx
Date: Fri, 11 Nov 2016 23:44:32 GMT
Content-Type: text/html
Transfer-Encoding: chunked
Connection: keep-alive
Vary: Accept-Encoding
P3P: CP='NOI CURa ADMa DEVa TAIa OUR DELa BUS IND PHY ONL UNI COM NAV INT DEM PRE'

여기부터 내용 시작
//위처럼 줄넘김으로 한 행을 비운다. 이것으로 해더가 끝난 것을 알 수 있다.

PHP로 파일 다루기
readfile("test.js"); 
이 방법으로 간단하게 파일을 읽을 수 있다. readfile()은 바로 출력한다. 
따라서 echo를 해줄 필요가 없다.
하지만 일반적으로는 fopen()함수를 이용한다.
$f = fopen("test.js", "r") or die("Unable to open file!"); // 읽기 모드로 파일 핸들러 오픈
echo fread($f,filesize("test.js")); // 파일 사이즈만큼 읽어들임 즉, 전체 읽음
fclose($f); // 파일 핸들러 종료

fopen(파일명, 모드)의 모드의 종류를 보자.
r	읽기 모드, 파일 포인터는 파일의 처음을 가리킨다.
w	쓰기 모드, 파일을 처음부터 새로 쓴다. 기존 것이 있어도 덮어 씌운다.
a	쓰기 모드, 파일 포인터는 파일 끝을 가리킨다. 기존 것이 있을 경우 그 내용 뒤에 덧붙여진다.
x	쓰기 모드, 이미 같은 이름의 파일이 존재하면 에러다.
r+ 읽기 쓰기 모드, 파일 포인터는 맨 처음을 가리킨다. 그리고 쓴만큼만 덮어씌운다.(얘가 제일 특이함)
w+ 읽기 쓰기 모드, 파일을 처음부터 새로 쓴다. 기존 것이 있어도 덮어 씌운다.
a+ 읽기 쓰기 모드, 파일 포인터는 파일의 끝. 기존 데이터는 보호된다.
x+ 읽기 쓰기 모드, 이미 같은 이름의 파일이 존재하면 에러다.

fread(핸들러, 읽을 길이 byte단위)
전체를 읽으려면 filesize('파일명')을 넣어준다. // 핸들러를 넣는 것이 아닌 것을 주의하자.

fgets(핸들러)
파일을 한줄만 읽은 문자열을 반환한다. 파일 포인터는 다음 줄로 이동한다.
s를 신택스라고 생각하자.

fgetc(핸들러)
파일을 한 글자만 읽는다. (한글을 3번 읽어야 한글자다.)
c를 캐릭터라고 생각하자.

feof(핸들러)
파일 포인터가 end of file일 때 true를 반환한다.
while(!feof(핸들러)) {
  echo fgets(핸들러) . "<br>";
}
이런식으로 길이를 모르는 파일을 읽을 때 유용하다.

새로운 파일을 작성해보자.
$f = fopen('test_file.txt', w);

이제 내용을 입력해 보자.
$txt = "어쩌고 저쩌고";
fwrite(핸들러, $txt);

PHP로 파일 올리기
<form action="upload.php" method="post" enctype="multipart/form-data">
    Select image to upload:
    <input type="file" name="fileToUpload" id="fileToUpload">
    <input type="submit" value="Upload Image" name="submit">
</form>
파일을 올리기 위한 폼이다.
메소드는 무조건 'post'여야 한다.
인코딩 타입도 무조건 enctype="multipart/form-data"
그리고 <input type="file">이 필요하다.

파일이 저장될 경로는 dirname($_SERVER['DOCUMENT_ROOT']).'/uploads/'로 하자.
dirname($_SERVER['DOCUMENT_ROOT'])은 www의 부모 디렉토리다.(웹에서 접근할 수 없음)

우선 폼으로 파일을 전송하면 tmp라는 임시 디렉토리에 저장되는데 
이것을 action 경로의 php파일에서 컨트롤 할 수 있게 된다.
파일에 대한 모든 정보는 $_FILES 슈퍼전역변수로 확인할 수 있다.
배열 내용은 다음과 같이 나온다.
array(1) {
  ["fileToUpload"]=>
  array(5) {
    ["name"]=>
    string(17) "54b8d9afc83d2.jpg"
    ["type"]=>
    string(10) "image/jpeg"
    ["tmp_name"]=>
    string(14) "/tmp/phpcz3XI5"
    ["error"]=>
    int(0)
    ["size"]=>
    int(44535)
  }
}

move_uploaded_file(임시파일 경로, 저장 경로) 
그리고 최종적으로 move_uploaded_file() 함수를 이용하여 임시파일을 원하는 경로에 저장한다.
단, 업로드하기 전에 사이즈, 중복 여부, 파일 종류 등을 확인해야 할 것이다.
임시 파일 경로는 $_FILES['파일 인풋 네임']['tmp_name'] 이렇게 접근할 수 있다.
따라서 move_uploaded_file($_FILES['인풋 네임']['tmp_name'], '경로/'.$_FILES['인풋 네임']['name']); 일반적으로 이런 코드가 나오게 된다.
정확히는 이런식으로 해주면 되겠다.
$target_dir = dirname($_SERVER['DOCUMENT_ROOT']);
if(move_uploaded_file($_FILES['file']['tmp_name'], $target_dir.'/uploads'.$_FILES['file']['name']))
$_FILES['file']['name']은 basename($_FILES['file']['name']) 이런식으로 basename()함수로 확실히 파일명만 확보하는 것이 더 좋다.

업로드 파일 저장에는 꼭 move_uploaded_file를 사용한다.
다른 함수를 사용할 경우 사용자가 상위 디렉토리에 접근할 가능성을 제공한다.

참고로 현재 페이지 url 구하는 방법
$current_url = "http://".$_SERVER['HTTP_HOST'].$_SERVER['REQUEST_URI'];

쿠키 다루기
setcookie(name, value, expire, path, domain, secure, httponly);
일반적으로 사용되는 파리미터는 name, value, expire, path 다.
setcookie('user_name', 'laura', time() + 84600*30, '/');
만료일은 time()함수를 이용한다. 현재시간을 초단위로 반환한다. 따라서 위처럼 84600(하루)에 원하는 지속 기간을 곱해준다.
**참고로 자스의 document.cookie로 설정할 땐 밀리세턴드로 써야 한다.
path는 디폴트로 ""(빈문자열)인데 이는 현재 파일 디렉토리 위치에 쿠키를 저장하게 된다.
그러면 해당 파일 디렉토리 에서만 $_COOKIE 등으로 접근할 수 있다.
path를 '/'로 해두면 사이트 전역에서 접근할 수 있다.
참고로 setcookie()로 쿠키를 만들 경우 새로고침을 하거나 다른 페이지로 한번 이동한 후부터 접근할 수 있다.(자스는 바로 가능)
쿠키 지우는 것은 역시 자스와 마찬가지로 과거 시간을 주면 된다.
setcookie("user", "", time() - 3600);
수정 역시 setcookie()를 사용한다.
** 착각하지 말자!! $_COOKIE 변수 값을 수정한다해도 실제 쿠키의 값이 바뀌는 것이 아니다!!

php에선 Data Filtering 라이브러리를 지원한다.
filter_has_var - 지정된 형식의 변수가 존재하는지 여부를 확인
filter_id - 필터의 이름에서 필터 ID를 반환
filter_input_array - 외부에서 변수를 받아보고 이러한 필터링
filter_input - 지정한 이름의 변수를 외부에서 수신 선택적으로 그것을 필터링
filter_list - 지원되는 필터 목록을 반환
filter_var_array - 여러 변수를 받아보고 이러한 필터링
filter_var - 지정된 필터로 데이터를 필터링 할

mysql 정리
$conn = new mysqli($servername, $username, $password);
다음과 같은 문법으로 mysqli 객체를 생성할 수 있다.
db 연결이 정상적으로 이루어졌는지 확인하기 위해선
$con->connect_error 프로퍼티로 확인할 수 있다. 에러가 있을 경우 true를 반환한다.
연결을 끊기 위해선
$conn->close();
쿼리의 정상적인 전송 확인을 위해선
$sql = "CREATE DATABASE myDB";
if ($conn->query($sql) === TRUE) {}
위처럼 $conn->query($sql)의 반환 결과를 보면된다. 에러가 없다면 true이다.

디비 선택 핸들러 생성 때 작성할 수도 있고 따로 할 수 도 있다.
$conn = new mysqli($servername, $username, $password, 'truekevin');
$con->select_db("truekein");

AUTO_INCREMENT 필드의 insert 또는 update된 마지막 id를 구하는 방법
query() 메소드 이후에 '$conn->insert_id' 프로퍼티를 통해 구할 수 있다.
query()핸들러(result 핸들러)가 아닌 mysqli()핸들러의 프로퍼티인 것을 잊지 말자.
참고로 num_rows는 result핸들러의 프로퍼티이다.
포스트 테이블처럼 나눠진 테이블에 같은 id로 레코드를 만들 때 꼭 필요하다.

mysql 준비된 문법 사용법
준비된 문법을 사용할 땐 query() 메소드를 사용하지 않는다.
준비된 문법은 반복적인 처리에 유용하고 빠르며 sql인젝션에 안전하다.
우선 준비된 문법을 만들고 파라미터를 바인딩한다.
// prepare and bind
$stmt = $conn->prepare("INSERT INTO MyGuests (firstname, lastname, email) VALUES (?, ?, ?)");
$stmt->bind_param("sss", $firstname, $lastname, $email);
설명:
prepare() 메소드로 준비된 쿼리를 정의하여 prepare 객체를 반환받는다. 또한 각각에 들어갈 값들을 '?'로 표시한다.
주의할 것은 ?에 따옴표가 없다는 것이다. 따옴표를 하면 문자열로 인식되므로 실수하지 말자.
prepare 객체의 bind_pram()메소드로 파라미터로 쓸 변수들의 이름을 미리 정의한다.
앞의 'sss'는 string, string, string 이란 의미다.
i - integer
d - double
s - string
b - BLOB
각각 다음과 같이 나타낼 수 있다.
$firstname = "John";
$lastname = "Doe";
$email = "john@example.com";
$stmt->execute();
그리고 각 변수명과 똑같은 변수에 데이터를 대입해준 뒤 execute()메소드를 실행한다.
위에서 정의한 변수에 밑에서 대입한다는 문법이 좀 특이하지만 익숙해지면 편할 듯하다.
lmit 절 사용법
lmit 0, 10 // 0옵셋부터 10개
=  limit 10과 같다.
lmit 20, 10 // 20옵셋부터 10개

터미널에서 mysql 접속방법
mysql -u 회원 -p //비번 입력
mysql -h호스트주소 -p포트번호 -u아이디 -p비밀번호
use 디비명

simplexml_load_string()과 simplexml_load_file() 함수가 있다.
둘다 std객체를 반환해준다.
json_decode() 역시 std객체를 반환한다.

std객체 만드는 방법
$aa = (object)array('a'=> 1, 'b'=> 2, 'c'=> 3, 'd'=> 4, '10'=> 5);
단, 위처럼 연관 배열일 경우에만 $aa->a 이런식으로 호출이 가능하다. 일반 배열이면 호출할 방법이 없다.
또한 $aa->10 이런식으로 숫자키는 호출할 수가 없다. 키들의 이름이 변수명 조건에 맞아야 한다는 것을 기억하자.
var_dump((array)$aa); // 이런식으로 다시 배열로 만들 수도 있다.

문자열 함수 정리
explode(분리자, 문자열)
문자열을 분리자로 분리한 배열을 반환한다.
implode(연결자, 문자열 배열)
해당 배열의 문자열은 연결자로 연결한다.
strlen(문자열)
문자열 길이를 반환한다. 한글은 한글자당 3이다.

배열 정렬 함수 정리
sort() - 값 기준 오름차순 정렬
rsort() - 값 기준 내침차순 정렬
asort() - 연상 배열을 값기준으로 오름차순 정렬
ksort() - 연상 배열을 키기준으로 오름차순 정렬
arsort() - 연상 배열을 값기준으로 내림차순으로 정렬
krsort() - 연상 배열을 키기준으로 내림차순으로 정렬
각각 연상 배열 일반 배열에 맞는 함수를 써야 한다는 것을 잊지말자. 다르게 쓰면 결과가 이상하게 나온다.
usort(배열, 콜백함수) 사용자 정의 방식으로 정렬할 수 있다.
**주의! 이 함수들은 모드 레퍼런스로 배열을 받는다. 따라서 리턴되는 값에 다시 저장할 필요가 없다.

sql 정리 
sql ANSI (American National Standards Institute) 표준이지만 db마다 다른 기능들도 가지고 있다.
sql 자체는 대소문자 구분을 하지 않는다. 다만 데이터들은 대소문자를 구분한다.
또한 문자 타입의 데이터를 입력할 때 ''(따옴표) 안에 쓰는 것을 잊지 말자!

distinct
distinct는 한개의 컬럼 기준으로 중복되지 않는 컬럼들만 보여준다.
중복되는 컬럼 중에 처음 것 한개만 표시된다.
예) select distinct 컬럼1, 컬럼2 ... from 디비
선택된 컬럼 기준으로 중복되지 않는 레코드만 출력한다.
저런식으로 두개의 컬럼으로 했을 경우 컬럼1끼리는 중복되는 데이터가 있을 수 있지만 컬럼1+컬럼2 레코드가 중복되는 것은 출력 안된다.

group by
distinct와 비슷한 효과를 얻을 수 있다.
SELECT City FROM Customers group by City;
SELECT DISTINCT City FROM Customers;
위 두 쿼리 다 같은 결과를 출력한다.
SELECT * FROM customers group by customername, city
셀렉트 되는 컬럼 따로 기준 따로 설정할 수 있어 group by가 더 유용하다.

where절
SELECT * FROM Customers
WHERE Country='Germany'
AND (City='Berlin' OR City='Munchen');
위와 같이 and, or를 결합하여 사용할 수 있다는 것을 잊지말자!(활용도 높음)

order by
SELECT * FROM Customers
ORDER BY Country ASC, CustomerName DESC;
위와 같이 정렬하는 기준을 여러개 둘 수 있다.
Country로 먼저 오름 차순으로 정렬 한뒤에 같은 Country끼리는 CustomerName으로 내림 차순으로 정렬한다.

insert into
insert into문법은 알다시피 두가지 방식이 있다.
INSERT INTO table_name VALUES (value1,value2,value3,...);
컬럼을 명시하지 않고 모든 컬럼의 값을 순서대로 입력한다.
INSERT INTO table_name (column1,column2,column3,...) VALUES (value1,value2,value3,...);
원하는 컬럼만 명시하여 값을 입력할 수 있다.
단, auto_increment_key의 경우는 인서트하지 않는다. (알아서 입력되니까)

update 테이블 set
UPDATE Customers SET ContactName='Alfred Schmidt', City='Hamburg' WHERE CustomerName='Alfreds Futterkiste';
where절을 잊지 말자!

delete from
DELETE FROM Customers
WHERE CustomerName='Alfreds Futterkiste' AND ContactName='Maria Anders';

sql 인젝션
1. where 절이 항상 참이 되게 만들기
UserId: 를 입력하는 인풋이 있다고 하자.
만약 사용자 101 or 1=1 같은 입력을 한다면...
SELECT * FROM Users WHERE UserId = 105 or 1=1 
위 상황에서 모든 Users레코드가 출력된다.
또는 User Name: " or ""=", Password: " or ""=" 이렇게 입력했다면
SELECT * FROM Users WHERE Name ="" or ""="" AND Pass ="" or ""=""
이런 쿼리가 만들어질 수도 있다. WHERE ""="" 은 언제나 참이다.
따라서 역시 모든 레코드가 출력된다.
2. 새미콜론 이용하기
user id: 105; DROP TABLE Suppliers 이런식의 쿼리가 들어온다면
SELECT * FROM Users WHERE UserId = 105; DROP TABLE Suppliers
모든 테이블을 박살낼지도 모른다.
3. 인젝션 공격을 피하는 법
가장 완벽한 방법은 prepare STATEMENT를 사용하는 것이다.

like 절
SELECT * FROM Customers
WHERE City LIKE 'b%';
주로 %연산자와 쓰인다.
SELECT * FROM Customers
WHERE NOT Country LIKE '%land%';
'NOT 컬럼 LIKE'로 포함되지 않는 것만을 찾을 수도 있다.

like 절에 쓸 수 있는 다른 와이들카드들
1. 위에서 %를 살펴봤다. %는 임의의 0개 이상의 모든 문자열을 뜻한다.
2. '_'는 임의의 1개의 문자를 뜻한다.
예) SELECT * FROM Customers WHERE City LIKE '_erlin';
이 경우 맨 앞글자가 뭐든 상과없고 그 뒤가 erlin인 문자열을 찾는다.
SELECT * FROM Customers WHERE City LIKE 'L_n_on';
이런식으로 여러개 쓸 수도 있다.
3. [] 와일드카드 mysql에서 지원하지 않는다.
예)  SELECT * FROM Customers WHERE City LIKE '[a-c]%';

in 절
SELECT * FROM Customers WHERE City IN ('Paris','London');
특히 in절은 서브쿼리를 사용할 때 유용하다.
SELECT * FROM Products NOT CategoryID IN (1,2,3);
'not 컬럼 like'처럼 'not 컬럼 in'도 가능하다.

between and 절
SELECT * FROM Products WHERE Price BETWEEN 10 AND 20;
영어의 between A and B 문법을 그대로 따른다. 즉, 10부터 20까지
SELECT * FROM Products WHERE NOT Price BETWEEN 10 AND 20
역시 NOT을 붙여 해당하지 않는 것만을 찾을 수 있다.
*** not은 항상 컬럼명 앞에 오는 것을 잊지 말자!!!

where절 결합
SELECT * FROM Products WHERE (Price BETWEEN 10 AND 20) AND NOT CategoryID IN (1,2,3);
이런식으로 쓸 수 있다.

Alias(별명)
별명은 select 절과 from 절에서 사용된다.
1. select 절에 사용될 경우
셀렉트할 때 컬럼명이 정의해준 별명으로 나온다.
SELECT post_title as title FROM `forum_post_header`
post_title 대신 title이 컬럼명으로 나온다.
2. from 절에 사용될 경우
SELECT o.OrderID, o.OrderDate, c.CustomerName
FROM Customers AS c, Orders AS o
WHERE c.CustomerName="Around the Horn" AND c.CustomerID=o.CustomerID;
보통 조인을 사용할 경우 유용하다.

concat 절
mysql에선 concat 으로 컬럼이 값들끼리 문자열 결합을 할 수 있다.
SELECT concat(post_id, post_title) FROM `forum_post_header`
이경우 컬럼명이 'concat(post_id, post_title)' 되고 레코드는
//24응시 자격증과 공인 영어 점수 제출 시기
//23안녕하세요.
이런식으로 출력된다.
컬럼명에 별명을 붙여주는 것이 더 좋아 보인다.
예) concat(post_id, post_title) as abcd

조인
조인은 조인 키워드를 쓰는 방식과 그냥 테이블명을 ',(콤마)'로 나열하는 방법이 있다.
전자의 경우 where 대신 on을 쓰고 후자는 where를 써야 한다.

inner join(join) 키워드
inner join 키워드는 그냥 join 키워드를 쓴 것과 같다.
inner join은 두 테이블의 교집합만 가지고 오는 조인이다.
1. join 키워드로
SELECT * 
FROM  `forum_post_header` join forum_post_body
on forum_post_header.post_id = forum_post_body.post_id
2. 콤마로
SELECT * 
FROM  `forum_post_header` , forum_post_body
WHERE forum_post_header.post_id = forum_post_body.post_id
**참고로 mysql에서 공백을 포함한 테이블, 컬럼명을 표기할 때 ``(역따옴표)를 사용한다.

left join
레프트 조인은 매칭 되는 것이 없어도 왼쪽 테이블은 모두 출력된다.
매칭 되지 않는 오른쪽 테이블의 컬럼들은 null이 된다.
SELECT Customers.CustomerName, Orders.OrderID
FROM Customers
LEFT JOIN Orders
ON Customers.CustomerID=Orders.CustomerID

right join
레프트조인과 반대라고 생각하면 된다.

full join
풀조인은 모든 레코드의 매칭을 출력한다. 즉, 카디널리티*카디널리티 수의 레코드가 출력된다.
1. FULL JOIN 키워드로
SELECT *  FROM  forum_post_header FULL JOIN forum_post_body
2. 콤마로
SELECT * FROM  forum_post_header,  forum_post_body

** 사실 레프트, 라이트 조인만 빼면 모두 콤마로 표기할 수 있다. 게다가 문장도 더 간결하다.

union
유니온은 셀렉트 결과를 세로로 이어준다고 보면 된다.
유니온되는 컬럼의 수는 같아야 한다.
같은 위치의 컬럼은 타입도 같아야 한다.
보통은 같은 컬럼들은 가지 테이블끼리 유니온한다.
문법
(select 문) union (select 문) // 중복되는 레코드는 출력안된다.
(select 문) union all (select 문) // 중복되는 레코드도 출력된다.
예)
(SELECT * FROM  `fun_post_header` WHERE 1)
UNION
(SELECT * FROM  `forum_post_header` WHERE 1)
**join키워드는 from절에 썼지만 union은 select문들 사이에 들어간다.

테이블 복사하기

- 복사할 테이블 존재하지 않을 경우 (테이블 생성 후 데이터 복사)
CREATE TABLE 복사할테이블명 SELECT * FROM 원본테이블명
단, 기본키나 인덱스에 대한 부분은 복사되지 않는다.
컬럼을 *로 하지 않으면 선택된 컬럼만 있는 테이블이 만들어진다.
예) CREATE TABLE 복사할테이블명 SELECT 컬럼명,... FROM 원본테이블명
- 테이블 스키마만 복사하고 싶은 경우
create table books3 SELECT * FROM books where 1=0; // 항상 거짓인 조건을 넣어준다.

-위 방법은 인덱스와 기본키 정보까지 복제 되지 않으므로 스키마만 복사 할 땐 다음과 같이 한다.
create table 새로운 테이블명 like 복사할 테이블명

- 복사할 테이블 존재하는 경우 (기존데이터를 바로 복사)
INSERT INTO 복사할테이블명 SELECT * FROM 원본테이블명
원하는 컬럼만 선택적으로 복사할 수 있다.(컬럼의 타입들이 같아야 할 것이다.)
INSERT INTO 복사할테이블명(컬럼명,...) SELECT 컬럼명,... FROM 원본테이블명

** 첫번째 방법은 배제하고 아래 두가지 방법을 이용하는 것이 제일 좋아 보인다.

create database 디비명
호스팅하는 입장이라 새로운 걸 만들 수는 없다. ㅠㅠ

create table 테이블명
테이블을 만들기위한 최소한의 데이터는 테이블명, 컬럼명, 컬럼 타입, 티입 사이즈이다.
CREATE TABLE table_name
(
column_name1 data_type(size),
column_name2 data_type(size),
column_name3 data_type(size),
....
);
CREATE TABLE Persons
(
PersonID int,
LastName varchar(255),
FirstName varchar(255),
Address varchar(255),
City varchar(255)
);
그외 추가적인 정보들이 많다.

테이블의 제약사항들(constraints)
1. not null
기본적으로 not null을 명시 안한 컬럼들은 디폴트 값이 null로 설정된다
하지만 not null 제약을 가진 컬럼은 다르다.
mysql에서 not null 컬럼에 아무것도 안 넣으면 ''(빈문자열)이 들어간다.
*따라서 'is null'에 해당되지 않는다.*
CREATE TABLE PersonsNotNull
(
P_Id int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255)
)

unique key와 primary key
둘 다 컬럼이 중복되는 값을 갖지 못하게 하는 제약이다.
단, 한 테이블에 unique key는 여러개 만들 수 있지만 primary key(기본키)는 하나까지만 있을 수 있다.
CREATE TABLE Persons
(
P_Id int NOT NULL UNIQUE KEY,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255)
)
CREATE TABLE Persons(
P_Id INT NOT NULL PRIMARY KEY ,
LastName VARCHAR( 255 ) NOT NULL ,
FirstName VARCHAR( 255 ) ,
Address VARCHAR( 255 ) ,
City VARCHAR( 255 )
)
위처럼 컬럼 옆에 써주면 된다.
두개 이상 컬럼의 묶음을 unique key와 primary key로 만드는 방법(각각이 아니라 묶어서 하나의 키인 것이다.):
CREATE TABLE Persons
(
P_Id int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName)
)
**mysql에선 이렇게 만들어도 어차피 키 이름은 primary가 된다.(네이밍 무의미)
CREATE TABLE Persons4(
P_Id INT NOT NULL ,
LastName VARCHAR( 255 ) NOT NULL ,
FirstName VARCHAR( 255 ) ,
Address VARCHAR( 255 ) ,
City VARCHAR( 255 ) ,
CONSTRAINT uc_PersonID UNIQUE KEY ( P_Id, LastName )
)
위처럼 CONSTRAINT 키워드를 이용한다.
CONSTRAINT 키이름 UNIQUE KEY (컬럼1, 컬럼2...)
CONSTRAINT 키이름 PRIMARY KEY (컬럼1, 컬럼2...)
키 이름을 명시해야 한다는 것을 잊지 말자!!
**mysql에선 간단하게 이런 문법도 지원한다.
CREATE TABLE Persons4(
P_Id INT NOT NULL ,
LastName VARCHAR( 255 ) NOT NULL ,
FirstName VARCHAR( 255 ) ,
Address VARCHAR( 255 ) ,
City VARCHAR( 255 ) ,
UNIQUE KEY ( P_Id, LastName )
)
CREATE TABLE Persons4(
P_Id INT NOT NULL ,
LastName VARCHAR( 255 ) NOT NULL ,
FirstName VARCHAR( 255 ) ,
Address VARCHAR( 255 ) ,
City VARCHAR( 255 ) ,
primary KEY ( P_Id, LastName )
)
이런식으로 따로 키 이름을 명시 안해도 알아서 네이밍 되어 만들어진다!!(이게 편하긴 한데 이름을 지을 수 없다.)

테이블 만든 후 키를 추가하거나 삭제하는 방법
1. 추가하는 방법
ALTER TABLE Persons
ADD primary key (P_Id, LastName) // 네이밍 알아서 되는 방식
ALTER TABLE Persons
ADD CONSTRAINT uc_PersonID UNIQUE key (P_Id,LastName) // CONSTRAINT 키워드 사용해서 네이밍하는 방식
방법은 ALTER 키워드를 쓰는 것을 빼면 테이블 만들 때와 거의 비슷하다.
2. 키를 삭제하는 방법(mysql 기준으로 기억하자.)
유니크키 삭제 방법:
ALTER TABLE 테이블명
DROP index 유니크키명
예)
ALTER TABLE Persons4
DROP index uc_PersonID
**'DROP index'를 기억하자 DROP unique key가 아니다! key들은 기본적으로 인덱스이기도 하다.
기본키 삭제 방법:
ALTER TABLE 테이블명
DROP primary key
**primary key의 인덱스명은 따로 명시 안해줘도 된다.

FOREIGN KEY(외래키)
외래키는 다른 테이블의 기본키를 참조하는 키를 말한다.
CREATE TABLE Orders
(
O_Id int NOT NULL,
OrderNo int NOT NULL,
P_Id int,
PRIMARY KEY (O_Id),
FOREIGN KEY (P_Id) REFERENCES Persons(P_Id)
)
mysql 기준으로 위와 같은 문법을 따른다.
먼저 기본키로 쓸 컬럼을 명시해준 뒤 외래키로 지정한다.
P_Id int,
FOREIGN KEY (외래키 컬럼명) REFERENCES 참조 테이블명(기본키 명)

키에 네이밍도 하고 싶다면 아래 처럼 한다.
CREATE TABLE Orders
(
O_Id int NOT NULL,
OrderNo int NOT NULL,
P_Id int,
PRIMARY KEY (O_Id),
CONSTRAINT fk_PerOrders FOREIGN KEY (P_Id) REFERENCES Persons(P_Id)
)

테이블 만든 후 외래키 추가하거나 삭제하는 방법
1. 추가하는 법
ALTER TABLE Orders
ADD FOREIGN KEY (P_Id) REFERENCES Persons(P_Id)
2. 삭제하는 법
ALTER TABLE Orders
DROP FOREIGN KEY 외래키명

check 제약
컬럼이나 테이블 자체의 입력 데이터 범위를 제한할 때 chack 키워드를 사용한다.
CREATE TABLE Persons65(
P_Id INT NOT NULL CHECK (P_Id >0), // p_Id는 항상 0보다 커야 한다.
LastName VARCHAR( 255 ) NOT NULL ,
FirstName VARCHAR( 255 ) ,
Address VARCHAR( 255 ) ,
City VARCHAR( 255 )
)

여러 컬럼에 제약을 주고 싶을 때
CREATE TABLE Persons
(
	P_Id int NOT NULL,
	LastName varchar(255) NOT NULL,
	FirstName varchar(255),
	Address varchar(255),
	City varchar(255),
	CONSTRAINT chk_Person CHECK (P_Id>0 AND City='Sandnes')
)
CONSTRAINT 키워드를 사용한다.

테이블 생성 후 check 추가, 삭제 방법
1. 추가하는 법
ALTER TABLE Persons
ADD CHECK (P_Id>0)
또는
ALTER TABLE Persons
ADD CONSTRAINT chk_Person CHECK (P_Id>0 AND City='Sandnes')
2. 삭제하는 법
ALTER TABLE Persons
DROP CHECK chk_Person

DEFAULT 제약
컬럼의 디폴트값을 설정할 수 있다.
CREATE TABLE Persons
(
P_Id int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255) DEFAULT 'Sandnes'
)

테이블 만든 후 DEFAULT를 삭제하거나 추가하는 법
1. 추가하는 법
ALTER TABLE Persons
ALTER City SET DEFAULT 'SANDNES'
2. 삭제하는법
ALTER TABLE Persons
ALTER City DROP DEFAULT

CREATE INDEX
인덱스를 설정하게 되면 업데이트 속도가 늦어진다.
대신 해당 컬럼의 검색 속도가 향상된다.
따라 셀렉트가 많이 되는 컬럼의 인덱스가 필요하다.
단순히 인덱스를 만들 때
CREATE INDEX 인덱스 이름 ON 테이블 이름 (컬럼명)
유니크 인덱스를 만들 때(컬럼들의 중복 불가)
CREATE UNIQUE INDEX 인덱스 이름 ON 테이블 이름 (컬럼명)
여러 컬럼을 인덱스로 묶을 수도 있다.
CREATE INDEX PIndex ON Persons (LastName, FirstName)
인덱스를 삭제하는 방법
DROP INDEX haha on Persons9

그 외의 DROP 문들
DROP DATABASE database_name
DROP TABLE table_name
TRUNCATE TABLE table_name //테이블 비우기(pk도 초기화 된다.)

ALTER TABLE 문
위에서 ALTER TABLE 문으로 테이블의 여러 옵션 사항들을 수정했었다.
이번에는 컬럼들을 추가, 수정, 삭제 하는 것을 알아보자.
1. 컬럼의 추가
마지막에 추가 : ALTER TABLE 테이블명 ADD 칼럼이름 칼럼타입 
지정 칼럼 뒤에 : ALTER TABLE 테이블명 ADD 칼럼이름 칼럼타입 AFTER 칼럼이름
제일 앞에 : ALTER TABLE 테이블명 ADD 칼럼이름 칼럼타입 FIRST
2. 컬럼의 삭제
ALTER TABLE 테이블명 DROP 컬럼명
3. 컬럼의 수정
ALTER TABLE 테이블명 MODIFY 컬럼이름 새컬럼타입
3. 컬럼 이름 변경
ALTER TABLE 테이블명 CHANGE 컬럼이름 새컬럼이름 새컬럼타입 // 컬럼 타입도 꼭 써줘야 한다!
4. 테이블 이름 변경
ALTER TABLE 테이블명 RENAME 바꿀이름
5. 테이블 형식 변경 
Engine 사용 : ALTER TABLE 테이블명 ENGINE=형식; 
type 사용 : ALTER TABLE 테이블명 TYPE=형식; 

AUTO_INCREMENT 키워드
CREATE TABLE Persons
(
ID int NOT NULL AUTO_INCREMENT,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
PRIMARY KEY (ID)
)
_(언더바)가 들어가는 것을 잊지 말자!

view(뷰)
뷰는 가상 테이블을 말한다.
뷰는 셀렉트만 가능하다.(따라서 어느정도 보안이 보장됨)
뷰를 만드는 문법:
CREATE VIEW 뷰 이름 AS (select 문)
뷰를 지우는 방법:
DROP VIEW 뷰 이름

mysql 날짜 함수
1. NOW()	현재 날짜+시간 반환
2. CURDATE()	현재 날짜 반환
3. CURTIME()	현재 시간 반환
4. DATE()함수
datetime 컬럼의 날짜 부분만 잘라서 보여준다.
SELECT DATE(post_date) FROM forum_post_header

NULL 판독법
where 절에서 NULL은 '컬럼명 = null'과 같은 형태로 쓰이지 않는다.
꼭 is null, in not null로 판독해야 한다.
예)
WHERE Address IS NOT NULL
WHERE Address IS NULL
주의! ''(빈문자열)도 null이 아니라는 점 기억하자.

ifnull() 함수
IFNULL(필드명, "대체할 값")
SELECT post_title, IFNULL( user_id,  '없어' ) FROM  forum_post_header WHERE user_id IS NULL
______________________________________
post_title /	ifnull(user_id, '없어')
아재아재	   /  없어
ㅁㄴㅇㄹ	   /  없어
asdf	     /  없어
ㅁㄴㄹ	     /  없어
ㅁㄴㅇㄹ	   /  없어
---------------------------------------
이런식으로 출력된다.
** 대체할 값에 다른 컬럼을 넣을 수도 있다.

mysql의 데이터 타입들
Int, Float, Char, Varchar, text, blob(이미지 등의 파일을 바이너리 데이터로 넣는다.)
희귀 타입들
ENUM(허용되는 값들) //나열된 것들만 값이 될 수 있는 필드가 된다.
예)
create table test(
 AA enum('안녕', '호랑이')
}
** enum()의 값들은 모두 문자열이다. 숫자를 넣더라도 '1'이렇게 문자열로 넣어줘야 에러가 안난다.
alter table test add test2 enum('안녕', '호랑이')
SET(허용되는 값들)
ENUM()과 거의 비슷하지만 데이터를 저장할 때 ',(콤마)'로 구분하여 여러 데이터를 넣을 수 있다는 점이 다르다.
test4 ('1', '2', '3') 이란 컬럼이 있다면 데이터를 인서트할 때
'1,2,3'을 넣을 수 있다. 
예) INSERT INTO `truekevin`.`test` (`test`, `test2`, `test4`) VALUES ('2', '안녕', '1,2,3');

SQL 함수들
SQL 함수는 '계량 함수'와 '스칼라 함수'로 나눌 수 있다. 

계량 함수
SQL 계량 함수들은 모두 하나의 값을 반환한다. 또한 select문에서 한줄의 레코드만 반환한다.(group by 쓰지 않는한)
1. avg(컬럼 이름): 해당 컬럼 값들의 평균값 반환
예) SELECT ProductName, Price FROM Products WHERE Price>(SELECT AVG(Price) FROM Products);
//서브쿼리를 이용해 평균 이상의 값인 것만 뽑아온다.
2. count()
COUNT(컬럼이름): 해당 컬럼의 값들의 수 (null인 것은 빠진다)
COUNT(*): 총 레코드 수를 반환한다.
COUNT(DISTINCT 컬럼이름): 중복되지 않는 컬럼 값의 수를 반환한다.
예) SELECT COUNT(*) AS OrdersFromCustomerID7 FROM Orders WHERE CustomerID=7;
3. max(컬럼 이름): 해당 컬럼의 제일 큰 값을 반환
예) SELECT * FROM Products where Price = (select MAX(Price) from Products);
// 가격이 제일 비싼 레코드를 출력한다.
4. min(컬럼 이름): 해당 컬럼의 제일 작은 값을 반환
예) SELECT * FROM Products where Price = (select min(Price) from Products);
// 가격이 제일 싼 레코드를 출력한다.
5. sum(컬럼 이름): 해당 컬럼의 값들의 합을 반환
SELECT SUM(Quantity) AS TotalItemsOrdered FROM OrderDetails;

group by
계량 함수들을 group by 키워드를 사용해 그룹화 할 수 있다.
(위쪽에서는 distinct 키워드와 비슷한 용도로 사용했지만 원래 용도는 이것이다.)
원래 계량 함수를 쓰면 하나의 레코드만 셀렉트 되지만 group by를 쓰면 각 컬럼 값별 함수 결과를 볼 수 있다.
예) SELECT city, count(*) FROM customers group by city
// city 값별 값들의 수를 알 수 있다.
예) SELECT CategoryID, avg(price) FROM Products group by CategoryID
// 카테고리별 가격의 평균을 알 수 있다.
컬럼들의 묶음으로 group by 하는 것도 가능하다.
예) SELECT * FROM Customers group by city, country
// 도시와 국가의 묶음으로 group by 했다. 다른 국가끼리 도시명이 같을 경우를 대비할 수 있다.

having
group by 문에는 where 대신 having절을 쓴다.(그렇지 않으면 한 쿼리에 where가 두번 나올 수도 있다.)
having절의 비교 대상은 항상 계량 함수가 된다. (where절에선 계량 함수로 비교할 수 없다.)
having절은 계량 함수로 비교하기 이한 키워드라고 생각해도 된다.
예) SELECT * FROM Suppliers group by country having count(*) > 2
테이블에 2개 이상 존재하는 국가의 레코드만 출력된다.

SQL 스칼라 함수
**계량 함수와는 다르게 레코드마다 각 값을 갖기에 레코드수는 그대로 출력된다.
1. UCASE(컬럼 이름): 해당 컬럼의 값을 대문자로 반환한다.
예) SELECT UCASE( user_id ) FROM forum_post_header
2. LCASE(컬럼 이름): 해당 컬럼의 값을 소문자로 반환한다.
예) SELECT LCASE( user_id ) FROM forum_post_header
3. mid(컬럼 이름, 시작, 길이): php의 substr() 함수와 같다.
단, 시작 인덱스가 0이 아닌 1이다!!
예) SELECT mid(post_title,1,1) FROM `forum_post_header
4. length(컬럼 이름): 문자열 길이를 반환한다.(한글의 한글자의 길이는 3이다.)
예) SELECT post_title, LENGTH( post_title ) FROM forum_post_header
5. ROUND(컬럼 이름, 표현할 소수점 자리수)
SELECT ProductName, ROUND(Price,0) AS RoundedPrice FROM Products;
// 소수점 표현 안함 따라서 소수점 첫째자리에서 반올림된 값이 리턴된다.(6.5->7)






