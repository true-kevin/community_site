id나 class는 숫자로 시작할 수 없다.

#center
.center
p.center
h1, h2, p

class="center large" 이런 식으로 여러 클래스 값을 가질 수 있다.

css의 정식 주석은 /* 내용 */ 이다.

<link rel="stylesheet" type="text/css" href="mystyle.css"> 익스터널 방식

익스터널, 인터널을 같이 쓰는 상황 또는 아닌 상황에 상관없이 셀렉터가 중복되어 있는 경우 가장 마지막에 작성된 스타일로 덮어쓰기 된다.(단, 인라인 방식은 절대적)
<head>
<link rel="stylesheet" type="text/css" href="mystyle.css">
<style>
h1 {
    color: orange;
}
</style>
</head>
위 방식은 인터널 방식으로 덮어쓰기 됨
<head>
<style>
h1 {
    color: orange;
}
</style>
<link rel="stylesheet" type="text/css" href="mystyle.css">
</head>
위 방식은 익스터널 방식으로 덮어쓰기 됨

블록 구분
블록 레벨 엘리먼트:
1. 가능한 가장 큰 width를 차지한다.
2. 앞과 뒤에 각각 한번씩 줄넘김을 한다.
3. width, height 값을 가질 수 있다.
예) <div>, <h1>~<h6>, <p>, <form>
인라인 엘리먼트:
1. 가능한 가장 작은 width를 차지한다. (엘리먼트 내부 요소에 맞춘다.)
2. 줄넘김을 하지 않고 위치한다.
3. width, height 값을 가질 수 없다.
예) <span>, <a>, <img>

background
background-color
background-image: url('경로') // html에선 src인데 css에선 url이다.
background-repeat // 디폴트로 수평, 수직 모두 repeat한다. 예) repeat-x, repeat-y, no-repeat
background-attachment // 예) fixed
background-position // '좌/우 위/아래'의 값을 가진다. 예) right top, center center, 50px 50px, 25% 75% (키워드, px, % 등이 다 지원됨)
background는 축약형으로 쓸 수 있다. 예) background: #ffffff url("img_tree.png") no-repeat right top;
축약형은 color, image, repeat, attachment, position 순서다. (중간에 빠지는 것은 상관 없지만 순서는 꼭 지켜져야 한다.)

border
border-style: solid; // 이런식으로 4면의 보더를 한번에 결정할 수 있다.
border-style: none; border-style: hidden; // 없애거나 숨길 수도 있다.
border-style: dotted dashed solid double; // 4면에 각각 다른 스타일을 적용할 수 있다.(순서는 top, right, bottom, left)
border-width: 2px; // 보더 굵기는 width라는 걸 기억하자.
border-width: 2px 10px 4px 20px; // 역시 4면을 각각 다르게 설정할 수 있다.
border-color: red; // 보더 컬러 역시 네임, rgb 등으로 설정 가능하다.
border-color: red green blue yellow; // 역시 4면의 색을 각각 다르게 설정할 수 있다.
보더 4면을 각각 선택할 수도 있다.
border-top-style: dotted;
border-right-style: solid;
border-bottom-style: dotted;
border-left-style: solid;
역시 축약형도 가능하다.
border: 5px solid red; (px, 스타일, 컬러 순서다.)
border-radius: 5px; 보더의 모서리를 둥굴게 만들 수 있다.

margin
margin은 보더 바깥의 여분 공간을 말한다.
margin-top: 100px;
margin-bottom: 100px;
margin-right: 150px;
margin-left: 80px;
또는
margin: 100px 150px 100px 80px;
이렇게 가능하다.
margin: auto; // 해당 엘리먼트를 가운데로 오게 한다.
주의! 'text-align: center'와 다른 점은 text-align은 해당 엘리먼트 '내의 요소(텍스트 포함)'의 정렬을 하는 것이고 margin: auto;는 해당 엘리먼트 '자체'를 가운데 정렬하는 것이다.
margin-left: inherit; // inherit 벨류를 명시하면 부모 엘리먼트의 값을 상속 받는다.
두 엘리먼트가 수직으로 맞 닿아 있을 때 위쪽 엘리먼트의 bottom 마진과 아래쪽 엘리먼트의 top마진이 겹쳐져서 둘 중 큰 쪽 마진만큼만 여분이 생기게 된다.(50px + 20px -> 50px)
이 현상은 오직 수직 구조에서만 나타난다!(수평 구조에선 안 나타남)

padding
padding은 보더와 내부 컨텐츠 사이의 여분 공간을 말한다.
padding-top: 50px;
padding-right: 30px;
padding-bottom: 50px;
padding-left: 80px;
또는
padding: 50px 30px 50px 80px;
이렇게 가능하다.

max-width //width의 최대값을 정해준다. 아무리 넓은 공간이 있어도 이 이상 커지지 않고 더 작아질 경우 줄어든다.

총 width, height를 계산하기 위해선 마진, 패딩도 잊지 말자!
320px (width) + 20px (left + right padding) + 10px (left + right border) + 0px (left + right margin) = 350px

outline
outline은 width와 height에 영향을 미치지 않는다.
outline-width // 두께 설정
outline-style // border-style과 같은 값들을 받는다.
outline-color // 컬러 설정
outline: 5px dotted red; // 축약형

text
text-align: justify; // 글자들의 간격 맞춰서 양옆에 알맞게 붙게 한다. (신문이나 잡지처럼)
text-decoration: // 예) none, line-through, underline
text-transform: // 예) uppercase(모두 대문자로), lowercase(모두 소문자로), capitalize(각 단어의 첫글자만 대문자로 표기)
text-indent: 50px // 첫글자의 시작 부분을 들여쓰기 한다.
letter-spacing: // 예) 3px, -4px (글자간의 좌우 간격을 명시한다.)
line-height: 0.7 // 줄간격을 명시한다. (엘리먼트의 height와 같은 값을 줘서 수직 가운데 정렬도 가능하다.)
word-spacing: 10px; // 단어 간격을 명시한다.

font
font-family: "Times New Roman", Times, serif; // 폰트 이름에 띄어쓰기가 있으면 ""으로 묶어 준다.
font-style: // 예) normal, italic, oblique
font-size:  // 예) 30px, 1.875em; /* 30px/16=1.875em */ em으로 설정하면 브라우저 내에서 조절 가능
body {font-size: 100%;} h1 {font-size: 2.5em;} // 이런 식으로 하면 모든 브라우저에서 같은 사이즈로 보이고 조절도 가능함
font-weight: // 예) normal, bold

아이콘들도 <i> <span> 태그로 쓸 수 있도록 지원해주는 곳이 있다. (구글, 부트스트랩 등)

list-style 태그
list-style-type: circle;
list-style-position: inside;
list-style-image: url('sqpurple.gif');
list-style: square inside url("sqpurple.gif");

테이블
vertical-align: center; // 테이블 td, th 엘리먼트는 수직적인 정렬도 맞출 수 있다.(top, middle or center, bottom) 
tr:nth-child(odd) {background-color: #f2f2f2} // 다음과 같은 셀렉터로 얼룩무늬를 만들 수 있다. even(짝수),odd(홀수)
tr:nth-child(odd):hover {} // 이런 식으로 겹쳐서도 가능하다.

인라인 엘리먼트 안에 블록 레벨 엘리먼트가 올 수 없다.
display: block을 통해 바꿔다 해도 마찬가지다.

display: none; // 공간을 차지하지 않고 레이아웃 자체에서 사라진다.
visibility: hidden; // 공간은 유지되고 레이웃도 유지되지만 보이지만 않는다.

position, left, top, right, bottom 프로퍼티
position: static; 은 디폴트로서 left, top, right, bottom 프로퍼티가 통하지 않는다.
position: relative; 기본 위치 기준에서 상대적으로 움직이게 된다. 단, 위치를 이동시킨다 해도 다른 레이아웃에 영향을 주지 않는다.(기본 레이아웃 유지)
position: fixed; 화면 위에 떠서 고정된다고 보면 된다. 좌표는 현재 화면 전체 기준에서 절대적으로 명시한다.(기본 레이아웃 파괴)
position: absolute; 바로위의 부모 엘리먼트 기준으로 좌표가 결정된다. 단, 부모가 포지션되어 있지 않으면 body를 기준으로 하게 된다.(기본 레이아웃 파괴)
포지션된 부모란 static(디폴트) '외에' 다른 포지션을 가지고 있는 부모 엘리먼트를 말한다.
z-index:는 엘리먼트가 겹쳤을 때 쌓이는 순서를 정해 준다. 값이 작을 수록 덮이게 된다. 예) -1, 1 낮은 값일 수록
주의! relative 좌표를 줄 때 잘 생각 해야 된다. right: 10px 하면 왼쪽으로 10px이동한다. 즉, 현재 위치 기준이기 때문에 헷갈릴 수 있다.
'left, top, right, bottom'을 '왼쪽/위쪽/오른쪽/아래로 ~만큼 이동'으로 이해하면 안되고 '왼쪽/위쪽/오른쪽/아래쪽으로부터 ~만큼 이동'으로 이해해야한다.

overflow
visible - Default. The overflow is not clipped. It renders outside the element's box (삐져나옴)
hidden - The overflow is clipped, and the rest of the content will be invisible (넘치는 거 자름)
scroll - The overflow is clipped, but a scrollbar is added to see the rest of the content (좌우 스크롤 생김)
auto - If overflow is clipped, a scrollbar should be added to see the rest of the content (필요한 스크롤 한 개만 생김)
overflow-x, overflow-y로 각각 따로 값을 줄 수도 있다.

float
float: left, float: right
clear: left, clear: right
left면 left로 클리어하고 right면 right로 클리어 한다. 간단하게 both를 써도 된다.

display: inline-block; 이 방식으로 블록 레벨 엘리먼트들을 인라인 엘리먼트처럼 사용할 수 있다. float을 쓰는 것보다 더욱 간단하다.
하지만 진짜 인라인 엘리먼트가 되는 것이 아니다. 왜냐 'width, height' 값을 줄 수 있기 때문이다.

img 엘리먼트에 display: block;을 줘서 margin: auto 등의 효과를 줄 수 있다.

Combinators 선택자
div p {} // div 내에 있는 모든 p가 해당됨 (모든 자손 즉, 자식, 손자, 증손자 모두 포함)
div > p {} // div 내에 있는 오직 '자식'인 p만 해당됨
div ~ p {} // div와 같은 깊이에 있는 모든 형제 p가 해당된다.
div + p {} // div 이후에 있는 형제 p 중에 가장 먼저 있는 p가 해당된다.

어트리뷰트 선택자
a[target] // a 중에 target 어트리뷰트가 있는 엘리먼트
a[target="_blank"] // a 중에 target 어트리뷰트의 벨류가 "_blank"인 엘리먼트
[title~="flower"] // title이 "flower"인 모든 엘리먼트
input[type=text] // 이런 거 할 때 유용함

수도 클래스
a:link, a:visited, a:hover, a:active // 이 4개를 다 적용할 땐 이 순서로 써줘야 한다.
div:hover // div를 마우스오버했을 때 div에 적용된다.
div:hover p // div를 마우스오버했을 때 div의 자식인 p에 적용된다.
p:first-child // 전체 엘리먼트 중에 가장 먼저 오는 p에 적용된다.
p:first-child i // 전체 엘리먼트 중에 가장 먼저 오는 p의 자손 i에 적용된다.
p i:first-child // p의 자손 중에 가장 먼저 오는 i에 적용된다. (부모 p가 여러개 있다면 여러번 적용될 수 있다.)
:focus 등 그외에 20~30개 정도의 수도 선택자가 더 있다.

투명도 조정
opacity: 0.4;
filter: alpha(opacity=40); /* For IE8 and earlier */
1이 디폴트 값이다. 0에 가까울 수록 투명해진다.
background: rgba(76, 175, 80, 0.6); // 마지막에 투명도 값을 넣을 수 있다.

긴 글이 줄넘김 되도록 하기
word-wrap: break-word;
word-break: break-all;


